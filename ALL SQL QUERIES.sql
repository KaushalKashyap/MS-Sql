CREATE DATABASE FIRSTDEMO;
USE FIRSTDEMO;

CREATE TABLE STUD
(RNO INT,
NAME VARCHAR(5),
AGE INT);

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (1, 'AJAY', 20);

INSERT INTO STUD
VALUES (2, 'Kash', 21);

INSERT INTO STUD (RNO,NAME)
VALUES (3, 'Kaus'); 
/* HERE WE HAVE NOT GIVEN AGE VALUE , SO FOR MAKE THIS SUCCESSFULL
 YOU HAVE TO SPECIFY AT INSERT TIME WITH HOW MANY COLUMN VALUE YOU ARE GOING TO GIVE. AND THE VALUE WILL STORED AS NULL*/

INSERT INTO STUD (NAME,RNO,AGE)
VALUES ('AMAN',4,33);
/* HERE WE ARE GIVING THE VALUE BUT IN SEQUENCE . SO FOR THAT WE ARE SPECIFYING THE COLUMN NAME AT INSERTING TIME*/

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (5, 'SHYAM', 25);

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (6, 'PARAM', 28);

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (7, 'SONU', 29);

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (8, 'ALI', 30);

INSERT INTO STUD ( RNO, NAME, AGE)
VALUES (9, 'SID', 40);

SELECT RNO, NAME, AGE FROM STUD


/* NOW LETS WORK WITH ANALYTICAL CONDITIONS */
/* ------ 1- WHERE ---------*/
SELECT * FROM STUD
WHERE AGE<30;
/* FINDING AGE BELOW 30 HOW MANY ARE THERE */

/* ------2- LIKE -------------*/
SELECT * FROM STUD
WHERE NAME LIKE 's%';
/* find the name who is starting with 's' */

SELECT * FROM STUD
WHERE NAME LIKE '%m';
/* find the name ending with 'm'*/

SELECT * FROM STUD
WHERE NAME LIKE '%A%';
/* HERE WE ARE FINDING IN THE NAME HOW MANY OF THEM HAVE 'A'.*/

SELECT * FROM STUD
WHERE NAME LIKE '____';
/* HERE UNDERSCORE IS REFER TO NO. OF CHARACTER. 
SO HERE WE ARE FINDING THAT HOW MANY OF NAME IS OF 4 CHARACTER ONLY.
THERE ARE FOUR UNDERSCORE GIVEN AT CONDITION. */

SELECT * FROM STUD
WHERE NAME LIKE '_A%';
/* HERE WE ARE FINDING TO THOSE NAME WHOSE SECOND CHARACTER ARE 'A' */

/* ---------3. TOP --------------*/
SELECT TOP 5 * FROM STUD;
/* HERE WE ARE GETTING TOP 5 DATA BY USING TOP */


/*-------------- UPDATE ---------------------*/
/* HERE COME THE DATA MANUPULATION ----------*/
UPDATE STUD SET AGE=19
WHERE RNO=3;

SELECT * FROM STUD

/* ------------ DELETE --------------------*/
/* ONCE DELETED NEVER BE UNDO --------*/
DELETE FROM STUD
WHERE RNO=3

SELECT * FROM STUD


/* ----------------------ALTER -----------------------------*/
/* ALTER IS BASICALLY USE FOR CREATE A NEW COLUMN, REMOVE A EXISTING COLUMN OR YOU CAN CHAGE THE ATTRIBUTE LIKE SIZE , DATATYPES ETC */

ALTER TABLE STUD
ADD CLASS CHAR(5)
SELECT * FROM STUD;
-- HERE WE HAVE CREATED A NEW COLUMN NAME 'CLASS' BY USING ALTAR

-- IF YOU WANT TO FILL THE DATA IN CLASS COLUMN. YOU CAN DO 
UPDATE STUD SET CLASS='1ST'

SELECT * FROM STUD;

-- IF YOU WANT TO REMOVE THE A COLUMN 

ALTER TABLE STUD
DROP COLUMN CLASS;
SELECT * FROM STUD;
-- HERE WE REMOVE CLASS COLUMN COMPLETELY

INSERT INTO STUD
VALUES (10,'KAMALPREET',25)
/* HERE YOU CAN SEE IT IS SHOWING ERROR "Msg 8152, Level 16, State 14, Line 111 , String or binary data would be truncated.
The statement has been terminated. " . IT MEANS YOU ARE INSERTING VALUE WHICH IS MORE THE GIVEN CHAR (SIZE). 
SO FOR THAT USE ALTER TO UPDATE THE DATATYPE AND ITS SIZE.*/

ALTER TABLE STUD
ALTER COLUMN NAME VARCHAR(15)
SELECT * FROM STUD;
-- HERE WE HAVE CHANGE THE DTYPE OF NAME COLUMN BY USING ALTER.

-- HERE WE WANT TO DELETE A WHOLE TABLE . 
-- DROP TABLE TABLENAME;
-- OR WANTED TO DELETE A WHOLE DATABASE
-- DROP TABLE TABLENAME;

-- PRIMARY Key: Uniquely identified each rows/records in a database table.
-- UNIQUE Constraint: Ensures that all values in a column are different.
-- NOT NULL Constraint: Ensures that a column cannot have NULL value.
-- DEFAULT Constraint : Provides a default value for a column when none is specified. CHECK Constraint: The
-- CHECK constraint ensures that all values in a column satisfy certain conditions.
-- FOREIGN Key: Uniquely identified a rows/records in any another database table.

-- SQL CLAUSES (" BETWEEN")
USE SQLCONSTRAINTS;
-- ' BETWEEN' WORKS AS LIKE RANGE . BELOW WE ARE FETCHING THE DATA FROM EMPLOYEETABLE WHERE EID <= GREATER THAN AND EQUAL TO E0009.
SELECT EID,NAME,EMAIL,PHONE FROM EMPLOYEEDETAILS WHERE EID<='E0009'

-- SQL CLAUSES (" IN "). IT WORKS LIKE A LIST. BELOW WE ARE FETCHING THOSE EMPLOYEE DATA WHOSE EID IS'E0009','E0005','E0003','E0006','E0004'.
SELECT * FROM EMPLOYEESALARY WHERE EID IN ('E0009','E0005','E0003','E0006','E0004'); 

-- SQL CLAUSES ("COUNT"). IT WILL GIVE YOU THE COUNT OF THE RECORDS
SELECT COUNT(*) FROM EMPLOYEEDETAILS; 

-- DISTINCT CLAUSES . IT WILL PROVIDE YOU UNIQUE VALUES IN THE ASKED COLUMN BUT IN SORTING FORM.
SELECT DISTINCT SALARY FROM EMPLOYEESALARY;

-- ORDER BY CLAUSES - IT IS USED FOR SORTING THE RECORD AND THEN DISPLAY. IT WILL NOT MAKE ANY CHANGE INSIDE DATABASE. BUT ONLY FOR DISPLAYING.
SELECT * FROM EMPLOYEESALARY ORDER BY SALARY; -- SALARY COLUMN WILL BE SORTED AS ASCENDING(DEFAULT).
-- OR,
SELECT * FROM EMPLOYEEDETAILS ORDER BY NAME,PHONE;
-- OR
SELECT EID, DEPT, DESIG, SALARY FROM EMPLOYEESALARY WHERE SALARY<521000 ORDER BY SALARY;
---------------------------------------------------------------------------------------------
SELECT * FROM EMPLOYEESALARY;
-- HERE WE ARE IN NEED TO CHANGE THE DATATYPE OF SALARY COLUMN. SO BELOW FEW LINES ARE FOR THAT UPDATION.
ALTER TABLE EMPLOYEESALARY
ADD SALARY INT;

UPDATE EMPLOYEESALARY SET SALARY= 521000 WHERE EID='E0001';
UPDATE EMPLOYEESALARY SET SALARY= 125000 WHERE EID='E0002';
UPDATE EMPLOYEESALARY SET SALARY= 332000 WHERE EID='E0003';
UPDATE EMPLOYEESALARY SET SALARY= 458000 WHERE EID='E0004';
UPDATE EMPLOYEESALARY SET SALARY= 224000 WHERE EID='E0005';
UPDATE EMPLOYEESALARY SET SALARY= 462000 WHERE EID='E0006';
UPDATE EMPLOYEESALARY SET SALARY= 264000 WHERE EID='E0007';
UPDATE EMPLOYEESALARY SET SALARY= 341000 WHERE EID='E0008';
UPDATE EMPLOYEESALARY SET SALARY= 351000 WHERE EID='E0009';
UPDATE EMPLOYEESALARY SET SALARY= 421000 WHERE EID='E0010';

-- UPDATE EMPLOYEESALARY SET SALARY= 521000,125000,332000,458000,224000,462000,264000,341000,351000,421000;
-------------------------------------------------------------------------------------------------
-- GROUP BY CLAUSES
-- SUPPOSE I WANT TO SEE TOTAL SALARY DEPARTMENT WISE- IN THIS DATA TABLE YOU WON'T BE ABLE TO FIND ANY DIFFERENCES BECAUSE ALL ARE UNIQUE.
-- BUT IN LARGE DATASETS YOU MAY EASILY FIND WHAT ARE THE DIFFERENCES.
SELECT DEPT, SUM(SALARY) FROM EMPLOYEESALARY GROUP BY DEPT;

SELECT COUNT(EID) AS 'TEAM MEMBER', DEPT, DESIG, SUM(SALARY) AS 'CUSTOMISED SAL' FROM EMPLOYEESALARY GROUP BY DEPT,DESIG,EID;
-- BELOW ARE FOR THOSE EMPLOYEE WHOSE SALARY GREATER THAN 150000.
SELECT COUNT(EID) AS 'TEAM MEMBER', DEPT, DESIG, SUM(SALARY) AS 'CUSTOMISED SAL' FROM EMPLOYEESALARY GROUP BY DEPT,DESIG,EID HAVING SUM(SALARY)> 150000;

-- SUPPOSE I WANTED TO KNOW TOTAL NUMBER OF EMPLOYEE AND SUM OF SALARY
SELECT COUNT(EID) AS 'TOTAL NUM OF EMP', SUM(SALARY) AS 'TOTAL SAL' FROM EMPLOYEESALARY;
-- BELOW ARE THE ALL MANAGERG GROUP BY DEPT AND THEIR TOTAL SALARY.
SELECT DEPT, COUNT(EID) AS 'NUMBER OF MANAGERS', SUM(SALARY) AS 'TOTAL SAL' FROM EMPLOYEESALARY WHERE DESIG='MANAGER' GROUP BY DEPT;
--SAME AS ABOVE ONLY WITH CONDITION SALARY IS GREATER THAN 200000. 
SELECT DEPT, COUNT(EID) AS 'NUMBER OF MANAGERS', SUM(SALARY) AS 'TOTAL SAL' FROM EMPLOYEESALARY WHERE DESIG='MANAGER' GROUP BY DEPT HAVING SUM(SALARY) >200000 ORDER BY SUM(SALARY)DESC;
---########################################################### JOINS ##############################################################--

------------- INNER JOIN --------------
-- IT WILL FETCH THE COMMON DATA FROM BOTH TABLE AND PRESENT THEM .
SELECT * FROM EMPLOYEEDETAILS;
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS INNER JOIN EMPLOYEESALARY ON EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

------------ LEFT JOIN ----------------
-- MATCHING FROM LEFT TABLE TO RIGHT TABLE

SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS LEFT JOIN EMPLOYEESALARY ON EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

----------------RIGHT JOIN -------------

SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS RIGHT JOIN EMPLOYEESALARY ON EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

--------------CROSS JOIN-----------------

SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY;
-- BELOW WILL SHOW SAME AS INNER JOIN SHOW: BCZ CROSS JOIN + WHERE= INNER JOIN.
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

--------------TABLE ALIASING (NICKNAMING THE TABLE NAMES)-----------

SELECT E1.EID,E1.NAME,E1.CITY,E1.EMAIL,E1.PHONE,E2.DEPT,E2.DESIG,E2.SALARY
FROM EMPLOYEEDETAILS E1  INNER JOIN EMPLOYEESALARY E2 ON E1.EID=E2.EID;



-------------------UNION -(LIKE AuB) PRESENT ONLY UNIQUE -----------------------------
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID
UNION
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

-------------------------UNION ALL ------------------------------------

SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID
UNION ALL
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;

--------------------------------INTERCEPT--------------------------------

SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID
INTERSECT
SELECT EMPLOYEEDETAILS.EID,EMPLOYEEDETAILS.NAME,EMPLOYEEDETAILS.CITY,EMPLOYEEDETAILS.EMAIL,EMPLOYEEDETAILS.PHONE,EMPLOYEESALARY.DEPT,EMPLOYEESALARY.DESIG,EMPLOYEESALARY.SALARY
FROM EMPLOYEEDETAILS CROSS JOIN EMPLOYEESALARY WHERE EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;




------------------------###########################---- INDEXES ----####################################---------------------------------
-- INDEX ALWAYS USED AS A FASTER WAY TO RETRIEVE DATA.

CREATE INDEX CITY_INDEX ON EMPLOYEEDETAILS (CITY);
-- IT WILL CREATE INDEX ONLY ON SINGLE COLUMN(CITY).

SELECT * FROM EMPLOYEEDETAILS;


-- COMPOSIT INDEX - IT CAN CREATE MORE THAN 1 COLUMN AT SINGLE TIME.

CREATE INDEX INDIX ON EMPLOYEEDETAILS (NAME,ADDR);


-- IMPLICIT INDEX ( AUTOMATIC - PRIMARY KEY/UNIQUE)
-- EXPLICIT INDEX ( WHAT WE CREATE - )

-- NON CLUSTERED INDEX
-- IT WILL MAKE NOTE OF ADDRESS OF THE DATA WHERE IT STORED
-- CLUSTERED INDEX
-- IT WILL SHUFFLE THE DATA PLACE OR DISPLACE IT 
CREATE CLUSTERED INDEX CLSTR ON EMPLOYEESALARY(DEPT);

---########################################## --FUNCTION --########################################################--
-- TWO TYPE OF FUNCTION IN SQL 1.-  TABLE VALUED FUNCTION  2.- SCALER VALUES FUNCTION
-- 1.- TABLE VALUE FUNCTIONS
USE SQLCONSTRAINTS;
CREATE FUNCTION FUNEMPLOYEEFUNCTION()
RETURN CHAR (20) 
AS 
RETURN (SELECT * FROM EMPLOYEEDETAILS);

-- 2.- SCALER VALUED FUNCTIONS

CREATE FUNCTION FUN_JOINEMPLOYEEINFO( @EID,@PHONE,@EMAIL,)
RETURN VARCHAR(100)
AS 
BEGIN RETURN (SELECT @EID, @PHONE, @EMAIL FROM EMPLOYEEDETAILS);
END;




--------##############################################-- VIEW --################################################------------------

-- WITH VIEW WE CAN CREATE A DIFFERENT ASPECTS LIKE . 
-- BELOW WE ARE CREATING A VIEW WHICH CONTAINS ONLY DATA OF THOSE WHOSE CITY IS 'DELHI'.
CREATE VIEW VIEW2 AS SELECT * FROM EMPLOYEEDETAILS WHERE CITY = 'DELHI';
-- VIEW IS CREATED FOR DELHI CITY EMPLOYEEES. NOW WHENEVER YOU CALL IT WILL ONLY DISPLAY
SELECT * FROM VIEW2;
-- WITHIN CREATED VIEW 'VIEW2' WE CAN INSERT UPDATE THE RECORD.
INSERT INTO VIEW2(EID,NAME,ADDR,EMAIL,PHONE,CITY) VALUES ('E0101','AKSHARA KHAN','LALPATI NIWAS','AKSHARAKHAN@YAHOO.COM',6201548978,'PUNJI');

SELECT * FROM VIEW2;
SELECT * FROM EMPLOYEESALARY WHERE DESIG='MANAGER';
USE SQLCONSTRAINTS;




------------- SUPPOSE YOU HAVE TO RETRIEVE DATA FROM TWO TABLE WITHOUT USING JOIN---------
-- SUPPOSE WE HAVE TO RETRIVE EMPLOYEE NAME EMAIL AND ADDRESS WITH SALARY

SELECT EID, NAME, ADDR, EMAIL FROM EMPLOYEEDETAILS
WHERE EID IN('E0002','E0004','E0008');

SELECT EID, NAME, ADDR, EMAIL FROM EMPLOYEEDETAILS WHERE EID IN(SELECT EID FROM EMPLOYEESALARY WHERE DESIG='MANAGER');

-- IT IS ALSO CALLED SUB QUERIES. bCZ WE ARE USING ANOTHER QUERY OUTPUT AS INPUT TO PERFORM MAIN OUTPUT.

SELECT EID, DEPT,DESIG, DOJ, SALARY FROM EMPLOYEESALARY 
WHERE EID IN(SELECT EID FROM EMPLOYEEDETAILS WHERE CITY ='DELHI');

------------------- INSERT SUBQUERY -----------------------------------------------------------------
USE SQLCONSTRAINTS;
CREATE TABLE TRAINING(
EID CHAR(6),
NAME VARCHAR(20),
CITY VARCHAR(25),
PHONE INT,
DEPT VARCHAR(20));
SELECT * FROM TRAINING;


INSERT INTO TRAINING (EID,NAME,CITY,DEPT)
SELECT EMPLOYEEDETAILS.EID,NAME,CITY,DEPT FROM EMPLOYEEDETAILS 
INNER JOIN EMPLOYEESALARY
ON EMPLOYEEDETAILS.EID=EMPLOYEESALARY.EID;


-------- UPDATE SUB QUERY ----------
UPDATE EMPLOYEESALARY SET SALARY = SALARY+ 5000
WHERE EID IN (SELECT EID FROM EMPLOYEEDETAILS WHERE CITY='DELHI');
SELECT * FROM EMPLOYEESALARY;


-----------------------------------------------------------------------------------------
-- DISPLAY NUMBER OF EMPLOYEE AND THEIR AVERAGE SALARY
SELECT COUNT(EID) 'NO OF MEMBERS', AVG(SALARY) AS 'AVGSAL' FROM EMPLOYEESALARY;
-- DISPLAY NUMBER OF EMPLOYEE AND THEIR AVERAGE SALARY WHOS CITY IS DELHI.
SELECT COUNT(EID) 'NO OF MEMBERS', AVG(SALARY) AS 'AVGSAL' FROM EMPLOYEESALARY
WHERE EID IN ( SELECT EID FROM EMPLOYEEDETAILS WHERE CITY ='DELHI');
-- DISPLAY NUMBER OF EMPLOYEE AND THEIR AVERAGE SALARY WHOS CITY IS DELHI AND SALARY IS LESS THAN 300000.
SELECT COUNT(EID) 'NO OF MEMBERS', AVG(SALARY) AS 'AVGSAL' FROM EMPLOYEESALARY
WHERE EID IN ( SELECT EID FROM EMPLOYEEDETAILS WHERE CITY ='DELHI' AND EID IN (SELECT EID FROM EMPLOYEESALARY WHERE SALARY > 300000));

-- 
SELECT * FROM EMPLOYEESALARY WHERE DEPT='CONSULT' 
AND EXISTS (SELECT * FROM EMPLOYEEDETAILS WHERE DEPT ='CONSULT' AND SALARY>371000);







USE DEMO_CONSTRAINTS;

CREATE TABLE EMP(
EID INT NOT NULL PRIMARY KEY,
NAME VARCHAR(20)NOT NULL,
ADDR1 VARCHAR(30)NOT NULL,
ADDR2 VARCHAR(15)NOT NULL,
CITY VARCHAR(15),
PHONE CHAR(13) NOT NULL,
EMAIL varchar(30)NOT NULL,
DOB DATE NOT NULL,
DOJ DATE NOT NULL);

SELECT * FROM EMP;

CREATE TABLE EMP_SAL(
EID INT FOREIGN KEY REFERENCES EMP(EID),
DEPT VARCHAR(15) NOT NULL,
DESIG VARCHAR(20) NOT NULL,
SALARY INT NOT NULL);

SELECT * FROM EMP_SAL;


-----#########################################################################################################################-------------------
------------------------------------------------------- PROCEDURE---------------------------------------------------------------
-- IT IS BASICALLY USED TO EXECUTE A PARTICULAR QUERY IN A SIMPLER FORM.

CREATE PROCEDURE DIRECTORSALARY
AS
BEGIN
	SELECT * FROM EMP_SAL WHERE DESIG='DIRECTOR';
END;

-- NOW TO EXECUTE IT IN SIMPLE WAY-
EXECUTE DIRECTORSALARY; 
-- OR USE SHORT FORM OF EXECUTE
EXEC DIRECTORSALARY;
-- OR DON'T EVEN USE EXECUTE WORD, SIMPLY WRITE THE PROCEDURE NAME
DIRECTORSALARY

-- WANT TO DROP THE PROCEDURE
DROP PROCEDURE DIRECTORSALARY;

-- PARAMETERISED PROCEDURE-------------------
-- IT IS USED TO PROVIDE THE OPTION "PARAMETER", SO AT THE TIME OF EXECUTION YOU JUST EXECUTE BY CALLING THOSE PARAMETERS.

CREATE PROCEDURE MANAGERSALARY @C VARCHAR(20)
AS 
BEGIN 
	SELECT * FROM EMP_SAL WHERE DESIG=@C;
END;

MANAGERSALARY 'MANAGER';
-- HERE WE ARE ASKING THAT IN THIS PROCEDURE GIVE ME THE INFORMATION OF THOSE WHOSE DESIG IS MANAGER.
-- THIS IS THE ADVANTAGE OF SIMPLICITY OF USING PROCEDURE.
--CHECK FOR ASSOCIATE
MANAGERSALARY 'ASSOCIATE';


-- HOW TO INSERT DATA INSIDE THE PROCEDURE
SELECT * FROM TRAINING;
CREATE PROCEDURE INSERTEMPSAL @ID INT, @NAM VARCHAR(10), @DEP VARCHAR(20), @DESI VARCHAR(25)
AS 
BEGIN
	INSERT INTO TRAINING 
	VALUES (@ID,@NAM,@DEP,@DESI);
END;
DROP PROCEDURE INSERTEMPSAL;
-- INSERT BY CALLING THOSE PROCEDURE
INSERTEMPSAL 1500,'OPS','VP','MASSAGER';
INSERTEMPSAL 1501,'OS','IP','ASSLICKER';

SELECT * FROM TRAINING;

-- IF YOU WANT INSERT THE DATA INSIDE THE PROCEDURE AND AT THE SAME TIME SHOW THAT THAT THE IS INSERTED.
DROP PROCEDURE INSERTEMPSAL;

CREATE PROCEDURE INSERTEMPSAL @ID INT, @NAM VARCHAR(10), @DEP VARCHAR(20), @DESI VARCHAR(25)
AS 
BEGIN
	INSERT INTO TRAINING 
	VALUES (@ID,@NAM,@DEP,@DESI);

	SELECT * FROM TRAINING
	WHERE EID=@ID;
END;

INSERTEMPSAL 1544,'MANU BHAI','PHARMACEUTICAL','DOCTOR';


-- SUPPOSE WE WANT TO INSERT DATA THROUGH PROCEDURE BUT NOT ONLY SINGLE , BUT IN TWO TABLES. LIKE EMP, EMP_SAL.
SELECT * FROM EMP;
SELECT * FROM EMP_SAL;

CREATE PROCEDURE INSERTEMPSAL @ID INT, @NAM VARCHAR(10), @ADD1 VARCHAR(20), @ADD2 VARCHAR(25), @CT VARCHAR(20), @PH INT, @EM VARCHAR(20), @DB DATE, @DJ DATE, @DPT VARCHAR(20),@DESI VARCHAR(20),@SAL INT
AS 
BEGIN
	INSERT INTO EMP 
	VALUES (@ID,@NAM,@ADD1,@ADD2,@CT,@PH,@EM,@DB,@DJ);

	INSERT INTO EMP_SAL 
	VALUES (@ID,@DPT,@DESI,@SAL);
END;

INSERTEMPSAL 1600, 'DEEPSHANKAR', 'SECTOR 512', 'HEMNAGAR', 'CHHAPRA', 8839133564, 'KK@GMAIL.COM', 07-03-1997, 10-11-1987,'OBS','MANAGER',1000000;

-- HERE YOU CAN SEE TWO TIME WRITTEN '1 ROW AFFECTED'.
-- IF YOU DON'T WANT TO SEE THE TWO TIME '1 ROW AFFECTED' . 
-- THEN WRITE   " SET NOCOUNT ON " AFTER BEGIN.

-- AND IF YOU WANT TO INSERT DATA IN TWO TABLE AS WELL AS SHOW THE DATA ALONG WITH INSERTION THEN.

CREATE PROCEDURE INSERTEMPSAL @ID INT, @NAM VARCHAR(10), @ADD1 VARCHAR(20), @ADD2 VARCHAR(25), @CT VARCHAR(20), @PH INT, @EM VARCHAR(20), @DB DATE, @DJ DATE, @DPT VARCHAR(20),@DESI VARCHAR(20),@SAL INT
AS 
BEGIN
	INSERT INTO EMP 
	VALUES (@ID,@NAM,@ADD1,@ADD2,@CT,@PH,@EM,@DB,@DJ);

	INSERT INTO EMP_SAL 
	VALUES (@ID,@DPT,@DESI,@SAL);

	SELECT * FROM EMP
	WHERE EID=@ID;

	SELECT * FROM EMP_SAL
	WHERE EID=@ID;


	SELECT EMP.EID, NAME, CITY,DOJ,DEPT,DESIG,SALARY AS 'BASIC',SALARY.0.15 AS 'HRA',SALARY*0.9 AS 'PF' 
	FROM EMP INNER JOIN EMP_SAL
	ON EMP.EID=EMP_SAL.EID
	WHERE EMP.EID=@ID

END;

-- WHAT IF WE CREATE A PROTOTYPE THAT TAKE TABLE NAME AND DISPLAY ALL RECORD. HERE WE ARE NOT ASSIGNING ANY TABLE NAME AT THE TIME OF CREATION.
USE DEMO_CONSTRAINTS;
CREATE PROCEDURE PROTOTYPE @T AS VARCHAR(20)
AS 
BEGIN
	EXEC('SELECT * FROM '+@T);
END;

PROTOTYPE 'EMP';





--####################################### TRANSACTIONS #############################################--
USE SQLCONSTRAINTS;
/*
TRANSACTION IS BASICALLY FOR MONITOR ANY TRANSACTION BETWEEN  TWO ENTITES. IT IS ACIDIC IN NATURE.

A- ATOMICITY - EITHER ALL PROCESS OF TRANSACTION HAPPEN SUCCESSFULLY, IF ANY ONE PROCESS FAILS ALL TRANSACTION SHOULD BE FAILED.
C- CONSISTENCY- ANY FAILURE OF TRANSACTION SHOULD NOT AFFECT ON OTHER TRANSACTIONS.
I- ISOLATION - ONCE TRANSACTION IS SUCCESSFULLY DONE. BOTH SIDE SHOULD BE UPDATED SUCCESSFULLY. 
D- DURABILITY- 
*/

CREATE TABLE REST(
RNO INT,
FCNAME VARCHAR(20));

SELECT * FROM REST;

INSERT INTO REST VALUES (1,'K');

INSERT INTO REST VALUES (2,'J');

INSERT INTO REST VALUES (3,'I');

INSERT INTO REST VALUES (4,'H');
-- HERE BELOW IF YOU USE DELETE CODE TO DELETE THE PARTICULAR DATA. YOU WON'T BE ABLE TO UNDO OR MAKE IT COMEBACK AGAIN TO THE TABLE.
DELETE FROM REST WHERE RNO=8

-- BUT WITH TRANSACTION YOU CAN UNDO THE DELETED DATA BY USING 'ROLLBACK'  .
BEGIN TRANSACTION
DELETE FROM REST WHERE RNO=8

SELECT * FROM REST;

ROLLBACK;

-- NOW USING SAVE TRANSACTION YOU CAN SAVE THIS PROCESS WITH THE NAMES T1,T2,T3,T4 AND WHEN USE ROLLBACK IT WILL UNDO ALL THE PROCESSES.
BEGIN 
SAVE TRANSACTION T4
DELETE FROM REST WHERE RNO=5

SAVE TRANSACTION T1
DELETE FROM REST WHERE RNO=8

SAVE TRANSACTION T2
DELETE FROM REST WHERE RNO=7


SELECT * FROM REST;

ROLLBACK;

-- OR YOU CAN USE ANY ONE TO ROLLBACK.
ROLLBACK TRANSACTION T2;

-- IF YOU WANT TO PROCESS IT FOR PERMANENTLY USE COMMIT AFTER PROCESS.
BEGIN TRANSACTION
DELETE FROM REST WHERE RNO=4;
COMMIT;

SELECT * FROM REST;
ROLLBACK; -- IT WILL SHOW THE ERROR WHERE IT SAYS, 'THE ROLLBACK TRANSACTION REQUEST HAS NO CORRESPONDING BEGIN TRANSACTION'

DROP TABLE REST;



----############################################################# AUTO INCREMENT ####################################################--
-- IF YOU TO LET SQL FILL THE DATA FOR EID. THEN ----
-- IDENTITY ONLY WORKS ON TABLE LEVEL. MEANS IT WILL WORK FINE 

CREATE TABLE BEST(
EID INT IDENTITY (1,1),-- HERE IDENTITY IS KEYWORD FOR AUTO INCREMENT AND (1,1) IS (START WITH 1, INCREMENT WITH 1).
NAME VARCHAR(20),
AGE INT);

INSERT INTO BEST (NAME,AGE) VALUES ('GAGAN TIWARI',28);

INSERT INTO BEST VALUES ('TIWARI GAGAN',30)
SELECT * FROM BEST;
-- AS YOU CAN SEE EID BEEN FILLED AUTOMATICALLY BY SQL ITSELF.

-- TO MAKE THING SIMPLE USE PROCEDURE FOR TABLE BEST.
CREATE PROCEDURE INBEST @N AS VARCHAR(20),@X AS INT
AS 
BEGIN
	INSERT INTO BEST
	VALUES(@N,@X);
	SELECT * FROM BEST;
END;

INBEST 'MOHAN TIWARI',32;
INBEST 'HARISH TRIPATHI',55;
DELETE FROM BEST WHERE EID=3
SELECT * FROM BEST;
-- AS YOU CAN SEE AFTER DELETING THE LAST DATA AND AGAIN INSERTION OF NEW DATA. WHERE SQL INSERT EID THE NEXT NUMBER FROM 
-- PREVIOUS NUMBER AFTER DELETING TOO..


--#################################################### SEQUENCE #####################################################################
-- SEQUENCE IS AN OBJECT OF SEQUAL.

CREATE SEQUENCE MYSEQ 
AS INT
START WITH 1
INCREMENT BY 1;

SELECT NEXT VALUE FOR MYSEQ;
-- THE BEST EXAMPLE OF 'SEQUENCE' IS THAT YOU MAY HAVE SEEN MANY WEBSITE WHICH SHOWS THE VISITOR COUNT I.E, HOW MANY VISITS TILL NOW HAPPENED.
-- BELOW SEQUENCE WILL HAVE MAXVALUE 10 WHICH WILL ENDUP AFTER REACHING IT MAX VALUE.
 CREATE SEQUENCE MYSEQ1
 AS INT
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 10;

SELECT NEXT VALUE FOR MYSEQ1;
-- AFTER EXECUTION TO REACH 10 YOU WILL SEE ERROR MSG. SO TO OVERCOME THIS ERROR WRITE AT THE END OF THE CODE CACHE 15 OR
-- ANY MAXVALUE NUMBER YOU WANT TO REACH.
-- BECAUSE YOU REACHED OF ITS MAX VALUE.
-- BELOW SEQUENCE WILL REACH TO ITS MAX VALUE AND THEN COMEBACK TO INITIAL POSITION. 
 CREATE SEQUENCE MYSEQ2
 AS INT
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 10
 MINVALUE 1
 CYCLE;
SELECT NEXT VALUE FOR MYSEQ2;

-- IMPLEMENT SEQENCE IN TABLES
CREATE SEQUENCE S
AS INT
START WITH 1
INCREMENT BY 1;
DROP SEQUENCE S;

CREATE TABLE SS
( ID CHAR(5),
NAME CHAR(10),
AGE INT);
DROP TABLE SS;

INSERT INTO SS VALUES(NEXT VALUE FOR S,'BABAN',28);
INSERT INTO SS VALUES(NEXT VALUE FOR S,'GAGAN',32);

SELECT * FROM SS;
------------------------------------------------------
-- FORVALUE THE EASE OF USER, CREATE PROCEDURE
CREATE PROCEDURE SSS @N CHAR(10),@AG INT
AS BEGIN
	INSERT INTO SS VALUES (NEXT VALUE FOR S,@N,@AG);

	SELECT * FROM SS;
END;	

SSS 'MAGAN',50;

-----------------------------------------------------
-- FOR ALPHANUMERIC VALUE TO STORE IN PRECEDURE
-- THIS WILL GENERATE THE ID AUTOMATICALLY BUT IN CHAR TYPE OR ALPHANUMERIC TYPE.

CREATE PROCEDURE SSIS @N AS VARCHAR(20), @AG INT
AS BEGIN
	
		DECLARE @I AS INT; -- THIS @I FOR THE NUMBER OF DIGIT WHICH IS PASSED BY SEQUENCE
		DECLARE @ID AS CHAR(5); -- DECLARE ID AS A

		SET @I = (NEXT VALUE FOR S);

		IF @I<10
			SET @ID=CONCAT ('E000', @I);
		ELSE IF @I<100
			SET @ID=CONCAT ('E00',@I);
		ELSE IF @I<1000
			SET @ID=CONCAT ('E0',@I);
		ELSE IF @I<10000
			SET @ID=CONCAT ('E',@I);
		ELSE
			SET @ID='NA';

			INSERT INTO SS VALUES(@ID,@N,@AG);
			SELECT * FROM SS;
END;

SSIS 'MAGAN',50;

-- THE SAME WILL WORK BUT ALSO THROUGH FUNCTION.
USE INVENTORY;
CREATE FUNCTION CID (@C AS CHAR(1), @I AS INT)
RETURNS CHAR(5)
AS 
BEGIN
	DECLARE	@ID AS CHAR(5);

	IF @I < 10
		SET @ID = CONCAT(@C,'000',@I);
	ELSE IF @I < 100
		SET @ID = CONCAT(@C,'00', @I);
	ELSE IF @I < 1000
		SET @ID = CONCAT(@C,'0',@I);
	ELSE IF @I <10000
		SET @ID = CONCAT(@C,@I);
	ELSE 'NULL' 
		--SET @ID = 'NA'
	END;
	RETURN @ID;
END;


-------------- ANOTHER FUNCTION FOR CID;

CREATE FUNCTION	CID (@C AS CHAR(1), @I AS INT) 
RETURNS CHAR(5)
AS
BEGIN
	DECLARE @ID AS CHAR(5);

	SELECT @ID = CASE
					WHEN @I<10 THEN CONCAT(@C,'000',@I)
					WHEN @I<100 THEN CONCAT(@C,'00',@I)
					WHEN @I<1000 THEN CONCAT(@C,'0',@I)
					WHEN @I<10000 THEN CONCAT(@C,@I)
					ELSE 'NA'
	END;
	RETURN @ID;
END;

SELECT DBO.CID('C',91);

--#############################################-TRIGGER-######################################################################
CREATE DATABASE CPCT;
USE CPCT;

CREATE TABLE PRODUCT(
PID CHAR(5),
PDESC VARCHAR(20),
PRICE MONEY);

INSERT INTO PRODUCT VALUES ('P0001','HP CAMERA 720P',320);
INSERT INTO PRODUCT VALUES ('P0002','HP CAMERA 1080P',420);
INSERT INTO PRODUCT VALUES ('P0003','HP CAMERA 1260P',520);
INSERT INTO PRODUCT VALUES ('P0004','HP CAMERA 1540P',620);
INSERT INTO PRODUCT VALUES ('P0005','HP CAMERA 2160P',720);
SELECT * FROM PRODUCT;

CREATE TABLE STOCK (
SID CHAR(5),
SQTY INT);

INSERT INTO STOCK VALUES ('S0001',120);
INSERT INTO STOCK VALUES ('S0002',200);
INSERT INTO STOCK VALUES ('S0003',150);
INSERT INTO STOCK VALUES ('S0004',230);
INSERT INTO STOCK VALUES ('S0005',450);

SELECT * FROM STOCK;

CREATE TABLE ORDERS ( 
OID CHAR(5),
PID CHAR(5),
CID CHAR(5),
QTY INT);

SELECT * FROM ORDERS;
-- INSERTED IS TEMPORARY TABLE WHICH WILL ACT WHEN TRIGGER EVENT COMES IN ACT.

CREATE TRIGGER TRIG_ORDERS
ON ORDERS
FOR INSERT 
AS 
BEGIN
	UPDATE STOCK SET SQTY=SQTY - (SELECT QTY FROM INSERTED)
	WHERE PID = (SELECT PID FROM INSERTED);
END;